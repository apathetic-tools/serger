# Iteration 16.2: Fix `detect_runtime_mode()` for Standalone Script Detection
> **Context**: See `current_plan/00_overview.md` for overall strategy and principles.
> **Previous**: See `current_plan/16.1_fix_remaining_source_path_issues.md` for iteration 16.1.

## Goal
Fix `detect_runtime_mode()` to correctly detect standalone mode when the script is loaded via `importlib` in test mode. The test `test_pytest_runtime_cache_integrity` fails because `detect_runtime_mode()` returns `"installed"` instead of `"standalone"` when `RUNTIME_MODE=singlefile`.

## Current Status

After iteration 16.1, we have:
- ✅ All `source_path` issues resolved
- ✅ All three previously failing tests now pass
- ❌ `test_pytest_runtime_cache_integrity` fails when `RUNTIME_MODE=singlefile`
- ❌ `detect_runtime_mode()` returns `"installed"` instead of `"standalone"` in standalone mode

## Problem Analysis

### Issue: `detect_runtime_mode()` Doesn't Detect Standalone Mode

**Test affected:**
- `test_pytest_runtime_cache_integrity` in `tests/0_tooling/test_pytest__runtime_mode_swap.py`

**Problem:**
When `RUNTIME_MODE=singlefile`, the test loads `dist/serger.py` via `importlib.util.spec_from_file_location()` and expects `detect_runtime_mode()` to return `"standalone"`. However, it returns `"installed"` instead.

**Root cause:**
The `detect_runtime_mode()` function in `src/apathetic_utils/system.py` checks:
```python
if "__STANDALONE__" in globals():
    return "standalone"
```

The issue is that `globals()` in this context refers to the globals of the `apathetic_utils.system` module, not the main script's globals where `__STANDALONE__ = True` is defined.

When the standalone script is loaded:
1. `__STANDALONE__ = True` is set at the top level of `dist/serger.py` (line 72)
2. The `apathetic_utils.system` module is part of the stitched script
3. When `detect_runtime_mode()` is called, it checks `globals()` which refers to the `apathetic_utils.system` module's globals
4. `__STANDALONE__` is not in that module's globals, so it falls through to `return "installed"`

**Current implementation:**
```python
def detect_runtime_mode() -> str:
    if getattr(sys, "frozen", False):
        return "frozen"
    if "__main__" in sys.modules and getattr(
        sys.modules["__main__"],
        __file__,
        "",
    ).endswith(".pyz"):
        return "zipapp"
    if "__STANDALONE__" in globals():
        return "standalone"
    return "installed"
```

**Solution:**
We need to check for `__STANDALONE__` in a way that works when the module is part of a stitched standalone script. Options:

1. **Check `sys.modules["__main__"]` for `__STANDALONE__`**: When the standalone script is loaded via `importlib`, it might be set as `__main__` or we can check the package module.

2. **Check the package module's globals**: Since the standalone script is loaded as the `serger` package, we can check `sys.modules["serger"]` for `__STANDALONE__`.

3. **Check `__file__` attribute**: We can check if the module's `__file__` points to `dist/serger.py` (but this is fragile if the path changes).

4. **Check parent frame's globals**: We can walk up the call stack to find the top-level module's globals.

**Best approach:**
Check multiple locations for `__STANDALONE__`:
- Check current module's globals (existing check)
- Check `sys.modules["__main__"]` if it exists and has `__STANDALONE__`
- Check the package module (`sys.modules.get("serger")`) if it exists and has `__STANDALONE__`
- Check if the module's `__file__` is `dist/serger.py` (fallback)

**Implementation:**
```python
def detect_runtime_mode() -> str:
    if getattr(sys, "frozen", False):
        return "frozen"
    if "__main__" in sys.modules and getattr(
        sys.modules["__main__"],
        __file__,
        "",
    ).endswith(".pyz"):
        return "zipapp"
    # Check for standalone mode in multiple locations
    # 1. Current module's globals (for when called from within standalone script)
    if "__STANDALONE__" in globals():
        return "standalone"
    # 2. Check __main__ module's globals
    if "__main__" in sys.modules:
        main_mod = sys.modules["__main__"]
        if hasattr(main_mod, "__STANDALONE__"):
            return "standalone"
    # 3. Check package module's globals (when loaded via importlib)
    pkg_name = "serger"  # Could also check sys.modules for any module with __STANDALONE__
    if pkg_name in sys.modules:
        pkg_mod = sys.modules[pkg_name]
        if hasattr(pkg_mod, "__STANDALONE__"):
            return "standalone"
    # 4. Check if __file__ points to dist/serger.py (fallback)
    current_file = __file__ if "__file__" in globals() else None
    if current_file:
        # Check if we're in the standalone script
        # This is a fallback - the __STANDALONE__ checks should catch it first
        pass  # Skip this for now, rely on __STANDALONE__ checks
    return "installed"
```

**Simpler approach:**
Since `__STANDALONE__` is set at the top level of the standalone script, and when loaded via `importlib`, the script becomes the `serger` package module, we should check `sys.modules["serger"]` for `__STANDALONE__`. But we also need to handle the case where the function is called from within the script itself.

Actually, a better approach: Check if any loaded module has `__STANDALONE__` in its globals. We can iterate through `sys.modules` and check for modules that have `__STANDALONE__` set.

**Even simpler:**
Since `__STANDALONE__` is defined at the top level of the standalone script, and when the script is executed, all modules share the same top-level namespace (they're all in the same file), we can check if `__STANDALONE__` exists in any of the relevant modules' globals.

**Best solution:**
Check the package module (`sys.modules.get("serger")`) for `__STANDALONE__`, since that's where the standalone script is loaded when using `importlib`:

```python
def detect_runtime_mode() -> str:
    if getattr(sys, "frozen", False):
        return "frozen"
    if "__main__" in sys.modules and getattr(
        sys.modules["__main__"],
        __file__,
        "",
    ).endswith(".pyz"):
        return "zipapp"
    # Check for standalone mode
    # 1. Current module's globals (for when called from within standalone script)
    if "__STANDALONE__" in globals():
        return "standalone"
    # 2. Check package module's globals (when loaded via importlib)
    # The standalone script is loaded as the "serger" package
    pkg_mod = sys.modules.get("serger")
    if pkg_mod is not None and hasattr(pkg_mod, "__STANDALONE__"):
        return "standalone"
    # 3. Check __main__ module's globals (for script execution)
    if "__main__" in sys.modules:
        main_mod = sys.modules["__main__"]
        if hasattr(main_mod, "__STANDALONE__"):
            return "standalone"
    return "installed"
```

## Changes

### 1. Fix `detect_runtime_mode()` (`src/apathetic_utils/system.py`)

**Location**: Function `detect_runtime_mode()` around line 64

**Current code:**
```python
def detect_runtime_mode() -> str:
    if getattr(sys, "frozen", False):
        return "frozen"
    if "__main__" in sys.modules and getattr(
        sys.modules["__main__"],
        __file__,
        "",
    ).endswith(".pyz"):
        return "zipapp"
    if "__STANDALONE__" in globals():
        return "standalone"
    return "installed"
```

**Updated code:**
```python
def detect_runtime_mode() -> str:
    if getattr(sys, "frozen", False):
        return "frozen"
    if "__main__" in sys.modules and getattr(
        sys.modules["__main__"],
        __file__,
        "",
    ).endswith(".pyz"):
        return "zipapp"
    # Check for standalone mode in multiple locations
    # 1. Current module's globals (for when called from within standalone script)
    if "__STANDALONE__" in globals():
        return "standalone"
    # 2. Check package module's globals (when loaded via importlib)
    # The standalone script is loaded as the "serger" package
    pkg_mod = sys.modules.get("serger")
    if pkg_mod is not None and hasattr(pkg_mod, "__STANDALONE__"):
        return "standalone"
    # 3. Check __main__ module's globals (for script execution)
    if "__main__" in sys.modules:
        main_mod = sys.modules["__main__"]
        if hasattr(main_mod, "__STANDALONE__"):
            return "standalone"
    return "installed"
```

**Rationale:**
When the standalone script is loaded via `importlib.util.spec_from_file_location()`, it's loaded as the `serger` package module. The `__STANDALONE__ = True` is set at the top level of that module, so we need to check `sys.modules["serger"]` for the attribute. We also check `__main__` for cases where the script is executed directly.

## Testing

### 1. Fix `detect_runtime_mode()`
- Update the function to check multiple locations for `__STANDALONE__`
- Run `test_pytest_runtime_cache_integrity` with `RUNTIME_MODE=singlefile` to verify it passes
- Run `test_pytest_runtime_cache_integrity` without `RUNTIME_MODE` (installed mode) to verify it still works
- Run existing `detect_runtime_mode` tests to ensure no regressions

### 2. Regression Testing
- Run full test suite to ensure no regressions
- Verify other runtime mode detection tests still pass
- Verify standalone script execution tests still pass

## Edge Cases

### 1. Module Not in `sys.modules`
- Handle case where `sys.modules.get("serger")` returns `None`
- Use `is not None` check before accessing attributes

### 2. `__main__` Not Set
- Handle case where `__main__` is not in `sys.modules`
- Use `in` check before accessing

### 3. Multiple Standalone Scripts
- The check should work even if multiple standalone scripts are loaded (unlikely but possible)
- The first check (current module's globals) should catch most cases

## Notes

- **Backward compatibility**: Should still work for all existing use cases
- **Performance**: Minimal overhead (just a few attribute checks)
- **Clarity**: Code should be clearly commented explaining why we check multiple locations

## Review and Clarifying Questions

**After implementing this iteration**, review the changes and document any questions:

1. **Review the implementation**:
   - Check that `detect_runtime_mode()` correctly detects standalone mode when loaded via `importlib`
   - Verify it still works for installed mode
   - Test with both `RUNTIME_MODE=singlefile` and without (installed mode)
   - Check edge cases (missing modules, etc.)

2. **Document any questions**:
   - Are there other locations where `__STANDALONE__` might be set?
   - Should we check other modules besides `serger`?
   - Are there performance concerns with checking multiple locations?

3. **Resolve before proceeding**:
   - Answer all questions before considering this feature complete
   - Update implementation if needed
   - Update documentation if behavior differs from plan

## Commit Message
```
fix(runtime): fix detect_runtime_mode() for standalone script detection

- Check package module (serger) for __STANDALONE__ when loaded via importlib
- Check __main__ module for __STANDALONE__ for script execution
- Maintain backward compatibility with existing checks
- Fix test_pytest_runtime_cache_integrity failure in singlefile mode
```

## Final Step: Update START_HERE.md

After completing this iteration, update `current_plan/START_HERE.md`:
- Mark iteration 16.2 as completed ✓
- Update the "Current status" section with what was accomplished
- Update "Next step" to point to next iteration (if any)
- Include a brief summary (e.g., "Fixed detect_runtime_mode() to correctly detect standalone mode when script is loaded via importlib")


# Iteration 03.5: Resolve Clarifying Questions

> **Context**: See `current_plan/00_overview.md` for overall strategy and principles.

## Goal
Resolve clarifying questions that should have been asked in previous iterations before proceeding with iteration 04. This ensures we have clear answers to design decisions that affect the implementation.

## Clarifying Questions

### Q1: When should default values be applied to module actions?

**Context**: The design doc mentions defaults for optional fields:
- `action`: default `"move"`
- `mode`: default `"preserve"`
- `scope`: default `"shim"` for user actions, `"original"` for mode-generated
- `affects`: default `"shims"`
- `cleanup`: default `"auto"`

**Question**: Should defaults be applied:
- **Option A**: At config resolution time (in `_validate_and_normalize_module_actions`) - all fields present in `BuildConfigResolved`
- **Option B**: Later when processing actions (in `module_actions.py`) - keep fields optional in `BuildConfigResolved`

**Decision needed**: **Option A** - At config resolution time (in `_validate_and_normalize_module_actions`) - all fields present in `BuildConfigResolved`

**Rationale**: 
- `BuildConfigResolved` is a "Resolved" TypedDict, meaning it should have all fields present with final values (per workspace rules)
- Applying defaults early ensures the resolved config is fully normalized and ready to use
- Makes the resolved config self-contained - no need to check for missing fields later
- Consistent with other resolved config fields (e.g., `post_processing` is always fully resolved)

---

### Q2: Should `BuildConfigResolved.module_actions` have all fields present with defaults?

**Context**: `BuildConfigResolved` is a "Resolved" TypedDict, meaning it should have all fields present with final values.

**Question**: Should `BuildConfigResolved.module_actions` be:
- **Option A**: `list[ModuleActionFull]` where all fields are present (defaults applied) - fully resolved
- **Option B**: `list[ModuleActionFull]` where optional fields remain optional - defaults applied later

**Decision needed**: **Option A** - `list[ModuleActionFull]` where all fields are present (defaults applied) - fully resolved

**Rationale**:
- Follows the "Resolved" TypedDict pattern - all fields should be present with final values
- Makes `BuildConfigResolved.module_actions` fully resolved and self-contained
- No need for downstream code to check for missing fields or apply defaults
- Consistent with the principle that resolved configs are "ready to use"

---

### Q3: When should `scope` defaults be set?

**Context**: The design doc says:
- User actions default to `scope: "shim"`
- Mode-generated actions default to `scope: "original"`

**Question**: Should we:
- **Option A**: Set `scope: "shim"` for all user actions at config resolution time (even though we don't know if they're mode-generated yet)
- **Option B**: Keep `scope` optional and set defaults later when we know if actions are mode-generated or user-specified
- **Option C**: Set `scope: "shim"` for user actions at config resolution, and mode-generated actions will set `scope: "original"` when they're created

**Decision needed**: **Option C** - Set `scope: "shim"` for user actions at config resolution, and mode-generated actions will set `scope: "original"` when they're created

**Rationale**:
- At config resolution time, we only have user-specified actions (mode-generated actions are created later in `stitch.py`)
- User actions should get `scope: "shim"` default at config resolution (per design doc)
- Mode-generated actions will be created with `scope: "original"` explicitly set when `generate_actions_from_mode()` is called
- This ensures user actions are fully resolved at config time, while mode-generated actions get their scope when created
- The two sets of actions are combined later, and each has the correct scope

---

### Q4: Should dict format actions have `scope: "shim"` set explicitly?

**Context**: The design doc says dict format defaults to `scope: "shim"` for user actions.

**Question**: When converting dict format to list format, should we:
- **Option A**: Explicitly set `scope: "shim"` in the normalized action
- **Option B**: Leave `scope` optional and set default later

**Decision needed**: **Option A** - Explicitly set `scope: "shim"` in the normalized action

**Rationale**:
- Design doc says dict format defaults to `scope: "shim"` for user actions
- Since we're applying defaults at config resolution (Q1), we should set `scope: "shim"` explicitly when normalizing dict format
- This ensures the resolved config has all fields present (per Q2)
- Makes the normalized action fully resolved and self-contained

---

### Q5: When should `dest` validation happen?

**Context**: The design doc says:
- `dest` is required for `move`/`copy`
- `dest` must not be present for `delete`

**Question**: Should we validate this:
- **Option A**: In iteration 04 (config resolution) - validate upfront
- **Option B**: Later when processing actions (iteration 07+) - validate when needed

**Decision needed**: **Option A** - In iteration 04 (config resolution) - validate upfront

**Rationale**:
- Design doc says `dest` is required for `move`/`copy` and must not be present for `delete`
- This is a structural validation that can be done without knowing the actual module tree
- Validating upfront catches configuration errors early, before any processing
- Better user experience - errors are caught at config resolution time, not later during action processing
- The validation is simple: check presence/absence based on action type

---

### Q6: Is `source_path` needed in iteration 03/04?

**Context**: The design doc mentions `source_path` for re-including excluded modules (section 19).

**Question**: Should we:
- **Option A**: Include `source_path` validation in iteration 04 (even if not used yet)
- **Option B**: Defer `source_path` handling to later iteration when it's actually needed

**Decision needed**: **Option B** - Defer `source_path` handling to later iteration when it's actually needed

**Rationale**:
- Design doc (section 19) says `source_path` is for re-including excluded modules - this is a future feature
- The current implementation doesn't need `source_path` yet - it's only used when actions reference modules that weren't included
- We can validate that `source_path` is a non-empty string if present (basic validation), but full implementation can wait
- This keeps iteration 04 focused on core validation and normalization
- When we implement `source_path` later, we'll add the full validation and processing logic

---

### Q7: What does `shim: "public"` mean and when should it be implemented?

**Context**: The design doc says `shim: "public"` means "Only generate shims for public modules (future: based on `_` prefix or `__all__`)".

**Question**: Should we:
- **Option A**: Implement `shim: "public"` now (even if basic implementation)
- **Option B**: Defer `shim: "public"` to later iteration
- **Option C**: Accept `"public"` as valid value but treat it same as `"all"` for now

**Decision needed**: **Option C** - Accept `"public"` as valid value but treat it same as `"all"` for now

**Rationale**:
- Design doc says `shim: "public"` means "Only generate shims for public modules (future: based on `_` prefix or `__all__`)" - it's explicitly marked as future functionality
- We should accept it as a valid value to avoid breaking configs that use it
- For now, treat it the same as `"all"` (generate shims for all modules)
- When we implement the actual "public" logic later, existing configs will automatically get the new behavior
- This follows the principle of accepting config early, even if not fully implemented yet

---

## Action Items

After answering all questions, update:
1. `current_plan/03_add_module_actions_types.md` - Add clarifications to the implementation
2. `current_plan/04_validate_module_actions_config.md` - Update based on decisions
3. Implementation code - Apply decisions consistently

## Testing
- No code changes in this iteration - just documentation and decision-making
- After decisions are made, update iteration 04 plan accordingly

## Notes
- This iteration is about clarifying design decisions, not implementing code
- All questions should be answered before proceeding to iteration 04
- Answers will guide the implementation approach


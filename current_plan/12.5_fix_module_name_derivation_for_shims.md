# Iteration 12.5: Fix Module Name Derivation for Shim Generation
> **Context**: See `current_plan/00_overview.md` for overall strategy and principles.
> **Prerequisites**: Iteration 12 must be completed first.

## Overview

Iteration 12 introduced support for `affects` and `cleanup` handling, which required preserving original module names for shim generation even when files are filtered from stitching. This introduced a bug where module names are derived incorrectly when `package_root` is a package directory itself, causing 4 tests to fail.

## Failing Tests

### Test 1: `test_scope_shim_actions_validated_incrementally`
**Location**: `tests/9_integration/test_module_actions_integration.py:147`

**Test Setup**:
- Files: `oldpkg/__init__.py`, `oldpkg/core.py`
- `package="mypkg"`, `module_mode="force"`
- User action: `{"source": "mypkg.oldpkg", "dest": "mypkg.newpkg", "scope": "shim"}`

**Expected Behavior**:
- Force mode generates `oldpkg -> mypkg` action (scope: "original")
- This creates `mypkg.oldpkg` in shim names
- User action `mypkg.oldpkg -> mypkg.newpkg` (scope: "shim") should validate successfully

**Actual Error**:
```
ValueError: Module action source 'mypkg.oldpkg' does not exist in available modules (scope: 'shim')
```

**Root Cause**:
- `package_root = tmp_path / "oldpkg"` (the package directory itself)
- `derive_module_name(oldpkg/__init__.py, package_root)` returns `"__init__"` (relative to package_root)
- `derive_module_name(oldpkg/core.py, package_root)` returns `"core"` (relative to package_root)
- `_original_order_names_for_shims = ["__init__", "core"]`
- After prepending `package_name`: shim names become `["mypkg.__init__", "mypkg.core"]`
- Force mode expects to operate on `"oldpkg"` but receives `["__init__", "core"]`
- Force mode generates action `oldpkg -> mypkg`, but this doesn't match any module names
- Result: `mypkg.oldpkg` is never created, so user action fails validation

### Test 2: `test_scope_original_and_shim_mixed`
**Location**: `tests/9_integration/test_module_actions_integration.py:187`

**Test Setup**:
- Files: `oldpkg/__init__.py`, `oldpkg/core.py`
- `package="mypkg"`, `module_mode="multi"`
- User actions:
  - `{"source": "oldpkg", "dest": "newpkg", "scope": "original"}`
  - `{"source": "mypkg.newpkg", "dest": "mypkg.finalpkg", "scope": "shim"}`

**Expected Behavior**:
- Original scope action: `oldpkg -> newpkg` creates `mypkg.newpkg` in shim names
- Shim scope action: `mypkg.newpkg -> mypkg.finalpkg` should validate successfully

**Actual Error**:
```
ValueError: Module action source 'mypkg.newpkg' does not exist in available modules (scope: 'shim')
```

**Root Cause**:
- Same as Test 1: `package_root = tmp_path / "oldpkg"`
- `_original_order_names_for_shims = ["__init__", "core"]` (missing package name)
- After prepending `package_name`: `["mypkg.__init__", "mypkg.core"]`
- Original scope action `oldpkg -> newpkg` doesn't match because module names are `__init__`, `core`, not `oldpkg`
- Result: `mypkg.newpkg` is never created, so shim scope action fails validation

### Test 3: `test_cleanup_error_raises_error_for_broken_shims`
**Location**: `tests/9_integration/test_module_actions_integration.py:421`

**Test Setup**:
- Files: `pkg1/__init__.py`, `pkg1/module.py`
- `package="mypkg"`, `module_mode="multi"`
- User action: `{"source": "pkg1", "action": "delete", "affects": "stitching", "cleanup": "error"}`

**Expected Behavior**:
- Action deletes `pkg1` from stitching (files filtered out)
- Shim generation still creates shims for `pkg1` (because `affects: "stitching"` only affects stitching)
- Mismatch detection finds broken shims pointing to deleted modules
- `cleanup: "error"` should raise `ValueError` about broken shims

**Actual Error**:
```
Failed: DID NOT RAISE <class 'ValueError'>
```

**Root Cause**:
- `package_root = tmp_path / "pkg1"` (the package directory itself)
- `_original_order_names_for_shims = ["__init__", "module"]` (missing package name)
- After prepending `package_name`: shim names become `["mypkg.__init__", "mypkg.module"]`
- Action source is `"pkg1"`, but shim names are `["mypkg.__init__", "mypkg.module"]`
- Mismatch detection in `check_shim_stitching_mismatches()` checks:
  - `broken_shim == "pkg1"` → false (`"mypkg.__init__" != "pkg1"`)
  - `broken_shim.endswith(".pkg1")` → false (`"mypkg.__init__"` doesn't end with `.pkg1`)
  - `".pkg1." in broken_shim` → false (`"mypkg.__init__"` doesn't contain `.pkg1.`)
  - `broken_shim.startswith("pkg1.")` → false (`"mypkg.__init__"` doesn't start with `pkg1.`)
- Result: No mismatches detected, so no error is raised

### Test 4: `test_affects_shims_only_affects_shim_generation`
**Location**: `tests/9_integration/test_module_actions_integration.py:271`

**Test Setup**:
- Files: `pkg1/__init__.py`, `pkg1/module.py`
- `package="mypkg"`, `module_mode="multi"` (default)
- User action: `{"source": "pkg1", "action": "delete", "affects": "shims"}`

**Expected Behavior**:
- Action deletes `pkg1` from shim generation only (files still stitched)
- File should still be stitched (module code should be present)
- Shim for `pkg1` should be deleted (no shim should exist for `pkg1` or `mypkg.pkg1`)

**Actual Error**:
```
assert '"pkg1"' not in normalized or '"mypkg.pkg1"' not in normalized
Failed: Both '"pkg1"' and '"mypkg.pkg1"' are present in output
```

**Root Cause**:
- `package_root = tmp_path / "pkg1"` (the package directory itself)
- `_original_order_names_for_shims = ["__init__", "module"]` (missing package name)
- After prepending `package_name`: shim names become `["mypkg.__init__", "mypkg.module"]`
- Action source is `"pkg1"`, but shim names are `["mypkg.__init__", "mypkg.module"]`
- Delete action in `_apply_delete_action()` checks:
  - `module_name == source` → false (`"mypkg.__init__" != "pkg1"`)
  - `module_name.startswith(f"{source}.")` → false (`"mypkg.__init__"` doesn't start with `pkg1.`)
- Result: Delete action doesn't match any shim names, so `pkg1` shims are not deleted
- Additionally, after fixing module name derivation, shim names become `["mypkg.pkg1", "mypkg.pkg1.module"]`
- Delete action source `"pkg1"` still doesn't match `"mypkg.pkg1"` because:
  - `"mypkg.pkg1" != "pkg1"` (exact match fails)
  - `"mypkg.pkg1"` doesn't start with `"pkg1."` (prefix match fails)
- Need to check if source appears as a component in the shim name path

## How Problems Were Identified

### Debugging Process

1. **Initial Observation**: After implementing iteration 12, 4 tests started failing
2. **Error Analysis**: All errors related to module names not being found in available modules
3. **Debug Logging**: Added logging to see what module names were being generated:
   ```python
   logger.debug("Checking mismatches: shim_modules=%d (%s), stitched_modules=%d (%s)", ...)
   ```
4. **Discovery**: Found that shim names were `['mypkg.__init__', 'mypkg.module']` instead of expected `['mypkg.pkg1', 'mypkg.pkg1.module']`
5. **Root Cause**: Traced back to `_original_order_names_for_shims` containing `['__init__', 'module']` instead of `['pkg1', 'pkg1.module']` or similar
6. **Package Root Investigation**: Discovered that `package_root` is the package directory itself (`tmp_path/pkg1`), not the parent directory
7. **Derivation Logic**: Confirmed that `derive_module_name(file_path, package_root)` returns names relative to `package_root`, losing the package name when `package_root` is the package directory

### Key Code Locations

- **File filtering section**: `src/serger/stitch.py:2404-2420` - Where `_original_order_names_for_shims` is built
- **Shim generation**: `src/serger/stitch.py:1811-1814` - Where `_original_order_names_for_shims` is used
- **Module name derivation**: `src/serger/utils/utils_modules.py:141` - `derive_module_name()` function
- **Package root determination**: `src/serger/build.py:558` - `find_package_root()` function
- **Mismatch detection**: `src/serger/module_actions.py:853` - `check_shim_stitching_mismatches()` function

## Changes from Iteration 12 That Caused the Problem

### Change 1: Added `_original_order_names_for_shims` Preservation
**Location**: `src/serger/stitch.py:2409-2420`

**What Changed**:
- Added code to preserve original module names before file filtering
- Uses `derive_module_name(file_path, package_root, include)` to build module names
- Stores result in `_original_order_names_for_shims` for later use in shim generation

**Why It Causes Problems**:
- When `package_root` is a package directory (e.g., `tmp_path/pkg1`), `derive_module_name()` returns names relative to that directory
- For `pkg1/__init__.py` with `package_root=tmp_path/pkg1`, it returns `"__init__"` instead of `"pkg1"` or `"pkg1.__init__"`
- This loses the package structure needed for:
  - Force mode to generate correct actions (needs `"oldpkg"`, not `"__init__"`, `"core"`)
  - Original scope actions to match correctly (needs `"oldpkg"`, not `"__init__"`, `"core"`)
  - Mismatch detection to find broken shims (needs `"pkg1"` in path, not just `"__init__"`, `"module"`)

### Change 2: Using `_original_order_names_for_shims` in Shim Generation
**Location**: `src/serger/stitch.py:1811-1814`

**What Changed**:
- Modified shim generation to use `_original_order_names_for_shims` when available
- This ensures shims are generated even when files are filtered from stitching

**Why It Causes Problems**:
- Uses incorrectly derived module names (missing package structure)
- These incorrect names propagate through the entire shim generation pipeline
- Results in shim names that don't match expected package structure

## Root Cause Analysis

### The Core Issue

When `package_root` is determined by `find_package_root()`, it returns the **lowest common ancestor** of all file paths. For test cases with a single package:

- Files: `tmp_path/pkg1/__init__.py`, `tmp_path/pkg1/module.py`
- `package_root = tmp_path/pkg1` (the package directory itself, not `tmp_path`)

When `derive_module_name()` is called with `package_root=tmp_path/pkg1`:
- `file_path.relative_to(package_root)` for `pkg1/__init__.py` → `__init__.py`
- Module name becomes `"__init__"` (loses `"pkg1"` prefix)

### Why This Matters

1. **Force Mode**: Generates actions based on detected packages (e.g., `oldpkg -> mypkg`). These actions need to match module names that include the package name (e.g., `"oldpkg"`), not just module files (e.g., `"__init__"`, `"core"`).

2. **Original Scope Actions**: Operate on the original module tree before package name prepending. They need module names that include the package structure (e.g., `"oldpkg"`), not just file names (e.g., `"__init__"`, `"core"`).

3. **Mismatch Detection**: Needs to match action sources (e.g., `"pkg1"`) against shim paths. If shim paths are `"mypkg.__init__"` instead of `"mypkg.pkg1"`, the matching logic fails.

## Proposed Solutions

### Solution 1: Fix Module Name Derivation for Package Directories

**Problem**: When `package_root` is a package directory, module names lose the package structure.

**Approach**: Detect when `package_root` is a package directory and adjust derivation accordingly.

**Implementation**:

1. **In file filtering section** (`src/serger/stitch.py:2410-2420`):
   - Before deriving module names, check if `package_root` is a package directory:
     ```python
     is_package_dir = (package_root / "__init__.py").exists()
     ```
   - If `is_package_dir` is True:
     - Use `package_root.parent` as the base for derivation instead of `package_root`
     - This preserves the package name in the module path
   - If `is_package_dir` is False:
     - Use `package_root` as before (normal case)

2. **Alternative approach** (if the above is too complex):
   - When `package_root` is a package directory, manually prepend the package name:
     ```python
     if is_package_dir:
         package_name_from_root = package_root.name
         module_name = f"{package_name_from_root}.{derive_module_name(...)}"
     ```

**Expected Result**:
- For `tmp_path/pkg1/__init__.py` with `package_root=tmp_path/pkg1`:
  - Module name becomes `"pkg1.__init__"` or `"pkg1"` (depending on handling of `__init__.py`)
- For `tmp_path/oldpkg/core.py` with `package_root=tmp_path/oldpkg`:
  - Module name becomes `"oldpkg.core"`

**Tests This Should Fix**:
- `test_scope_shim_actions_validated_incrementally` - Force mode will find `"oldpkg"` in module names
- `test_scope_original_and_shim_mixed` - Original scope action will match `"oldpkg"` correctly

### Solution 2: Improve Mismatch Detection for Package Names

**Problem**: Mismatch detection can't match action source `"pkg1"` against shim paths like `"mypkg.__init__"`.

**Approach**: Enhance mismatch detection to check if the action source appears as a component in the shim path.

**Implementation**:

1. **In `check_shim_stitching_mismatches()`** (`src/serger/module_actions.py:890-904`):
   - Current logic checks:
     - Exact match: `broken_shim == source`
     - Ends with: `broken_shim.endswith(f".{source}")`
     - Contains: `f".{source}." in broken_shim`
     - Starts with: `broken_shim.startswith(f"{source}.")`
   
   - Add check for package component match:
     ```python
     # Check if source appears as a path component in broken_shim
     # e.g., "mypkg.pkg1.module" contains "pkg1" as a component
     elif source in broken_shim.split("."):
         action_broken_shims.add(broken_shim)
     ```

2. **Note**: This is a **defensive fix** that helps even if Solution 1 is applied, but Solution 1 should make this unnecessary in most cases.

**Expected Result**:
- For action source `"pkg1"` and shim `"mypkg.pkg1.module"`:
  - `"pkg1" in "mypkg.pkg1.module".split(".")` → `True`
  - Mismatch is detected correctly

**Tests This Should Fix**:
- `test_cleanup_error_raises_error_for_broken_shims` - Mismatch detection will find broken shims

### Solution 3: Handle `__init__.py` Special Case

**Problem**: When deriving module names, `__init__.py` files need special handling to represent the package itself.

**Approach**: When a module name is `"__init__"` (from `__init__.py`), it should be represented as the package name, not `"__init__"`.

**Implementation**:

1. **In file filtering section** (`src/serger/stitch.py:2415-2420`):
   - After deriving module name, check if it's from `__init__.py`:
     ```python
     module_name = derive_module_name(file_path, package_root, include)
     # If this is __init__.py and package_root is a package directory,
     # use the package name instead
     if is_package_dir and file_path.name == "__init__.py":
         package_name_from_root = package_root.name
         # Use package name as the module name (represents the package itself)
         module_name = package_name_from_root
     ```

2. **Alternative**: Handle this in `derive_module_name()` itself, but that might affect other callers.

**Expected Result**:
- For `tmp_path/pkg1/__init__.py` with `package_root=tmp_path/pkg1`:
  - Module name becomes `"pkg1"` (the package itself)
- For `tmp_path/pkg1/module.py` with `package_root=tmp_path/pkg1`:
  - Module name becomes `"pkg1.module"` (with Solution 1) or `"module"` (needs package prepending)

**Tests This Should Fix**:
- All three tests (ensures package is represented correctly)

### Solution 4: Improve Delete Action Matching for Package Components

**Problem**: Delete actions with `affects: "shims"` can't match shim names when the action source appears as a component in the shim path (e.g., source `"pkg1"` vs shim `"mypkg.pkg1"`).

**Approach**: Enhance delete action matching to check if the source appears as a component in the module name path.

**Implementation**:

1. **In `_apply_delete_action()`** (`src/serger/module_actions.py:519-554`):
   - Current logic checks:
     - Exact match: `module_name == source`
     - Prefix match: `module_name.startswith(f"{source}.")`
   
   - Add check for component match:
     ```python
     # Check if source appears as a component in module_name
     # (e.g., "mypkg.pkg1" contains "pkg1" as a component)
     if source in module_name.split("."):
         # Source is a component: delete it
         continue
     ```

2. **In shim scope action validation** (`src/serger/stitch.py:1937-1944`):
   - Skip source validation for delete actions (they match flexibly):
     ```python
     action_type = action.get("action", "move")
     if action_type != "delete":
         validate_action_source_exists(action, set(shim_names), scope="shim")
     ```

**Expected Result**:
- For action source `"pkg1"` and shim `"mypkg.pkg1"`:
  - `"pkg1" in "mypkg.pkg1".split(".")` → `True`
  - Delete action matches and removes the shim
- For action source `"pkg1"` and shim `"mypkg.pkg1.module"`:
  - `"pkg1" in "mypkg.pkg1.module".split(".")` → `True`
  - Delete action matches and removes the shim

**Tests This Should Fix**:
- `test_affects_shims_only_affects_shim_generation` - Delete action will match and remove shims correctly

**Note**: This solution is partially implemented but the test still fails. The issue may be that shim names are being generated in a way that creates both `"pkg1"` and `"mypkg.pkg1"` entries, or the delete action is not being applied at the right point in the pipeline. Further investigation needed.

## Implementation Strategy

### Recommended Order

1. **Start with Solution 1** (fix module name derivation) - This addresses the root cause
2. **Add Solution 3** (handle `__init__.py`) - This ensures packages are represented correctly
3. **Add Solution 2** (improve mismatch detection) - This provides defensive coverage
4. **Add Solution 4** (improve delete action matching) - This fixes delete actions with `affects: "shims"`

**Note**: Solutions 1, 2, and 3 are implemented and fix Tests 1, 2, and 3. Solution 4 is partially implemented but Test 4 still fails, indicating additional work is needed.

### Testing Strategy

After each solution:
1. Run the specific failing test to verify the fix
2. Run all module action integration tests to ensure no regressions
3. Run full test suite to ensure broader compatibility

### Verification Steps

For each test:
1. **Test 1** (`test_scope_shim_actions_validated_incrementally`):
   - Verify that `mypkg.oldpkg` exists in shim names after force mode
   - Verify that user action `mypkg.oldpkg -> mypkg.newpkg` validates successfully

2. **Test 2** (`test_scope_original_and_shim_mixed`):
   - Verify that `mypkg.newpkg` exists in shim names after original scope action
   - Verify that user action `mypkg.newpkg -> mypkg.finalpkg` validates successfully

3. **Test 3** (`test_cleanup_error_raises_error_for_broken_shims`):
   - Verify that shim names include `pkg1` (e.g., `mypkg.pkg1`, `mypkg.pkg1.module`)
   - Verify that mismatch detection finds broken shims
   - Verify that `ValueError` is raised with `cleanup: "error"`

4. **Test 4** (`test_affects_shims_only_affects_shim_generation`):
   - Verify that shim names include `pkg1` (e.g., `mypkg.pkg1`, `mypkg.pkg1.module`)
   - Verify that delete action with `affects: "shims"` matches and removes shims
   - Verify that `"pkg1"` and `"mypkg.pkg1"` are not present in output
   - Verify that file is still stitched (module code present)

## Context for Independent Problem Solving

### For Test 1 & 2 (Scope Validation)

**Key Files**:
- `src/serger/stitch.py:2404-2420` - File filtering and module name derivation
- `src/serger/stitch.py:1811-1814` - Shim generation using preserved names
- `src/serger/utils/utils_modules.py:141` - `derive_module_name()` function
- `src/serger/module_actions.py:731` - `generate_actions_from_mode()` for force mode
- `src/serger/module_actions.py:628` - `_generate_force_actions()` implementation

**Key Concepts**:
- `package_root` is the lowest common ancestor of all files (may be a package directory)
- Force mode generates actions based on detected packages, not module names
- Original scope actions operate on module names before package name prepending
- Module names need to include package structure for actions to match correctly

**Debugging Tips**:
- Add logging to see what `package_root` is: `logger.debug("package_root: %s", package_root)`
- Add logging to see derived module names: `logger.debug("_original_order_names_for_shims: %s", original_order_names_for_shims)`
- Add logging to see shim names after force mode: `logger.debug("shim_names after force: %s", shim_names)`

### For Test 3 (Cleanup Mismatch Detection)

**Key Files**:
- `src/serger/stitch.py:2404-2420` - File filtering and module name derivation
- `src/serger/stitch.py:1979-1984` - Mismatch detection and cleanup
- `src/serger/module_actions.py:853` - `check_shim_stitching_mismatches()` function
- `src/serger/module_actions.py:911` - `apply_cleanup_behavior()` function

**Key Concepts**:
- Mismatch detection compares shim module names against stitched module names
- Action sources are package/module names (e.g., `"pkg1"`)
- Shim names are full paths (e.g., `"mypkg.pkg1.module"`)
- Matching logic needs to find the source as a component in the shim path

**Debugging Tips**:
- Add logging in `check_shim_stitching_mismatches()`:
  ```python
  logger.debug("Checking mismatch: source=%s, broken_shim=%s", source, broken_shim)
  logger.debug("Match results: exact=%s, endswith=%s, contains=%s, startswith=%s",
                broken_shim == source,
                broken_shim.endswith(f".{source}"),
                f".{source}." in broken_shim,
                broken_shim.startswith(f"{source}."))
  ```
- Add logging to see what shim names are generated:
  ```python
  logger.debug("shim_names: %s", shim_names)
  logger.debug("stitched_modules_full: %s", stitched_modules_full)
  ```

### For Test 4 (Delete Action with affects: "shims")

**Key Files**:
- `src/serger/stitch.py:2404-2440` - File filtering and module name derivation
- `src/serger/stitch.py:1937-1944` - Shim scope action application
- `src/serger/module_actions.py:519` - `_apply_delete_action()` function
- `src/serger/module_actions.py:56` - `validate_action_source_exists()` function

**Key Concepts**:
- Delete actions with `affects: "shims"` are applied to shim names after prepending `package_name`
- Action source is original module name (e.g., `"pkg1"`)
- Shim names are full paths after prepending (e.g., `"mypkg.pkg1"`)
- Delete action matching needs to check if source appears as a component in shim name
- Delete actions should skip source validation (they match flexibly)

**Debugging Tips**:
- Add logging in `_apply_delete_action()`:
  ```python
  logger.debug("Delete action: source=%s, module_name=%s, match=%s",
                source, module_name, source in module_name.split("."))
  ```
- Add logging to see shim names before and after delete action:
  ```python
  logger.debug("Shim names before delete: %s", shim_names)
  shim_names = apply_single_action(shim_names, action, detected_packages)
  logger.debug("Shim names after delete: %s", shim_names)
  ```

## Related Code Sections

### File Filtering Logic
```python
# src/serger/stitch.py:2404-2420
original_order_names_for_shims: list[str] | None = None
if module_actions:
    module_to_file_for_filtering: dict[str, Path] = {}
    for file_path in order_paths:
        include = file_to_include.get(file_path)
        module_name = derive_module_name(file_path, package_root, include)  # ← Problem here
        module_to_file_for_filtering[module_name] = file_path
    original_order_names_for_shims = list(module_to_file_for_filtering.keys())
```

### Shim Generation
```python
# src/serger/stitch.py:1811-1814
if _original_order_names_for_shims is not None:
    shim_names_raw = list(_original_order_names_for_shims)  # ← Uses incorrect names
else:
    shim_names_raw = list(order_names)
```

### Mismatch Detection
```python
# src/serger/module_actions.py:890-904
for broken_shim in broken_shims:
    if (
        broken_shim == source
        or broken_shim.endswith(f".{source}")
        or f".{source}." in broken_shim
        or broken_shim.startswith(f"{source}.")
    ):
        action_broken_shims.add(broken_shim)
```

## Success Criteria

All four tests must pass:
1. ✅ `test_scope_shim_actions_validated_incrementally` - No validation errors
2. ✅ `test_scope_original_and_shim_mixed` - No validation errors
3. ✅ `test_cleanup_error_raises_error_for_broken_shims` - Raises `ValueError` as expected
4. ⚠️ `test_affects_shims_only_affects_shim_generation` - Delete action removes shims correctly (separate issue, needs additional fix)

Additionally:
- ✅ All other tests continue to pass (no regressions)
- ✅ `poetry run poe check:fix` passes completely

## Commit Message

```
fix(stitch): preserve package structure in module names for shim generation

- Fix module name derivation when package_root is a package directory
- Preserve package name in _original_order_names_for_shims
- Handle __init__.py special case to represent package correctly
- Improve mismatch detection to handle package name components
- Fixes scope validation tests and cleanup error detection

Fixes 3 failing tests:
- test_scope_shim_actions_validated_incrementally
- test_scope_original_and_shim_mixed  
- test_cleanup_error_raises_error_for_broken_shims

Note: test_affects_shims_only_affects_shim_generation still fails due to delete
action matching logic needing to handle source as component in shim paths.
This is a separate issue from the module name derivation fix.
```

## Next Steps After Fixing

1. Run `poetry run poe check:fix` to verify all tests pass
2. Update `current_plan/START_HERE.md` to mark iteration 12.5 as completed
3. Document any edge cases discovered during fixing
4. Proceed to next iteration (if any) or mark module actions feature as complete

